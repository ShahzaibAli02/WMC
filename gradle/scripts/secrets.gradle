import groovy.transform.Field

import javax.crypto.Cipher
import javax.crypto.KeyAgreement
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec
import java.security.*
import java.security.spec.*

@Field private static final String BACKEND_PUBLIC_KEY =
        "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEz7svvqDHBU5QqjM48zo3nAIVWVvN3agkGzSE7Up0dpsg/REQFSG5jmmw5Eyw9Q45+voB2EEsbPRsS8piJur93w=="

@Field private static final byte[] EMPTY_IV = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
]

/*
 * Usage: ./gradlew encryptSecret -DVALUE={string to be encrypted}
 */
task encryptSecret {
    doFirst {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))
        String message = reader.readLine()
        println "SECRET ENCRYPTED : " + encrypt(message)
    }
}

/*
 * Special task to generate backend keys. Only needed once to set up backend.
 */
task generateBackendSecretKeys {
    doFirst {
        KeyPair keys = generateKeys()

        println "BACKEND PRIVATE KEY: " + Base64.encoder.encodeToString(keys.private.encoded)
        println "BACKEND PUBLIC KEY: " + Base64.encoder.encodeToString(keys.public.encoded)
    }
}

ext.secret = { String value ->
    try {
        return decrypt(value)
    } catch (Exception ex) {
        throw new IllegalArgumentException("Cannot decrypt the secret: ${ex}", ex)
    }
}

private static encrypt(String message) {
    // First we need to generate a special shared secret key that will be used to encrypt the
    // message. Backend already has it's own set of private & public keys, and we need to generate
    // temporary private & public keys such that:
    // f(local-private-key, backend-public-key) = f(backend-private-key, local-public-key)
    // Where f is a special agreement function, see getSharedSecret() method.
    // Output of this function will be our shared secret key.
    // See also:
    // https://gist.github.com/ymnk/fec39e033394ee2ec47c
    // https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption

    // Generating temporary local private & public keys
    KeyPair tmpLocalKey = generateKeys()
    // Getting shared secret
    String secret = getSharedSecret(tmpLocalKey.private, asPublicKey(BACKEND_PUBLIC_KEY))
    // Generating key out of secret passphrase
    SecretKey key = getEncryptionKey(secret)

    // Now we'll use symmetric aes256-cbc algorithm to encrypt the message
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")

    // Since we are using different secret keys for every message we are more or less fine to use
    // all-zeroes IV, just to make encrypted text a bit shorter (we'll not need to include IV),
    // See: https://security.stackexchange.com/questions/35210/encrypting-using-aes-256-do-i-need-iv
    AlgorithmParameterSpec specs = new IvParameterSpec(EMPTY_IV)
    cipher.init(Cipher.ENCRYPT_MODE, key, specs)
    // If you got InvalidKeyException please update your java

    byte[] encrypted = cipher.doFinal(message.getBytes("UTF-8"))

    // Encrypted string should contain encrypted message and our temporary public key.
    // All of this is required to decode the string back.
    return Base64.encoder.encodeToString(encrypted) + "|" +
            Base64.encoder.encodeToString(tmpLocalKey.public.encoded)
}

private static decrypt(String message) {
    // See algorithm description in encrypt() method above. Decryption algorithm consists of
    // getting shared secret key and then reversing aes256-cbc encryption.

    final String privateBackendKey = findBackendKey()
    if (privateBackendKey == null) return null // We are not on the backend, can't decipher

    // Getting encrypted message and temporary public key used to encrypt the message
    String[] parts = message.split("\\|")
    if (parts.length != 2) throw new IllegalArgumentException("Invalid encrypted message format")

    byte[] encrypted = Base64.decoder.decode(parts[0])
    PublicKey tmpPublicKey = asPublicKey(parts[1])

    // Getting shared secret
    String secret = getSharedSecret(asPrivateKey(privateBackendKey), tmpPublicKey)
    // Generating key out of secret passphrase
    SecretKey key = getEncryptionKey(secret)

    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(EMPTY_IV))
    return new String(cipher.doFinal(encrypted), "UTF-8")
}

private static KeyPair generateKeys() {
    final String curve = "secp256r1"
    KeyPairGenerator kpg = KeyPairGenerator.getInstance("EC", "SunEC")
    kpg.initialize(new ECGenParameterSpec(curve))
    return kpg.genKeyPair()
}

private static String getSharedSecret(PrivateKey localPrivateKey, PublicKey remotePublicKey) {
    KeyAgreement agreement = KeyAgreement.getInstance("ECDH")
    agreement.init(localPrivateKey)
    agreement.doPhase(remotePublicKey, true)
    return Base64.encoder.encodeToString(agreement.generateSecret())
}

private static PrivateKey asPrivateKey(String key) {
    KeyFactory factory = KeyFactory.getInstance("EC", "SunEC")
    byte[] bytes = Base64.decoder.decode(key)
    return factory.generatePrivate(new PKCS8EncodedKeySpec(bytes))
}

private static PublicKey asPublicKey(String key) {
    KeyFactory factory = KeyFactory.getInstance("EC", "SunEC")
    byte[] bytes = Base64.decoder.decode(key)
    return factory.generatePublic(new X509EncodedKeySpec(bytes))
}

private static String findBackendKey() {
    String home = System.getenv('HOME')
    if (home == null) return null
    File file = new File("${home}/secrets/backend_android_private_key")
    if (!file.exists() || !file.isFile()) return null
    return file.getText("UTF-8")
}

private static SecretKey getEncryptionKey(String secret) {
    // Randomly generated salt (not a secret)
    final byte[] salt = [
            (byte) 0x2f, (byte) 0xb6, (byte) 0x20, (byte) 0x56,
            (byte) 0xbe, (byte) 0xd5, (byte) 0x46, (byte) 0x04
    ]
    final int iterations = 65536
    // We could use 256, but since we are using elliptic curve of length 256 then 128 should be
    // enough. See https://crypto.stackexchange.com/questions/61248/aes-and-ecdh-key
    final int keySize = 128
    KeySpec spec = new PBEKeySpec(secret.toCharArray(), salt, iterations, keySize)
    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
    return new SecretKeySpec(factory.generateSecret(spec).getEncoded(), "AES")
}
